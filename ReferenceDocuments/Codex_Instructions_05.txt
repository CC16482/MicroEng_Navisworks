Below is a complete “Codex work order” for a new **Viewpoints Generator** tool (WPF UI) that batch-creates **Saved Viewpoints** in Navisworks from:

* **Current selection** (single viewpoint), or
* **Selection/Search Sets** (one viewpoint per set), or
* **Property grouping** (one viewpoint per distinct value — optional Phase 2)

It is designed to be consistent with your existing pattern (Smart Set Generator): a themed WPF window, hosted via an `ElementHost` in a dock pane plugin, plus a command to show it.

---

## Codex work order: Viewpoints Generator tool

### Goal

Create a new tool “Viewpoints Generator” that:

1. **Previews** a list of viewpoints to be created (name, source, item count).
2. **Generates** Saved Viewpoints into a folder path (e.g., `MicroEng/Viewpoints`).
3. Uses a predictable camera preset (Iso/Top/Front/etc) and fits to item bounds with a margin.
4. Runs entirely via **WPF UI**, matching your existing window hosting approach.

### Non-goals for MVP (Phase 2 upgrades)

* Full “Search in / Scope tree” parity with Find Items (can be added later + shared with Smart Sets).
* Section box / cut planes and visibility isolate capture (can be added after MVP works).
* Screenshot export / BCF / issue markup (Phase 2).

---

## 1) Add new folder + files

Create folder:

`MicroEng.Navisworks/ViewpointsGenerator/`

Add these files:

1. `ViewpointsGeneratorModels.cs`
2. `ViewpointsGeneratorNavisworksService.cs`
3. `ViewpointsGeneratorControl.xaml`
4. `ViewpointsGeneratorControl.xaml.cs`
5. `ViewpointsGeneratorWindow.xaml`
6. `ViewpointsGeneratorWindow.xaml.cs`
7. `ViewpointsGeneratorPlugins.cs`

---

## 2) Implement models

### `ViewpointsGeneratorModels.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace MicroEng.Navisworks.ViewpointsGenerator
{
    public enum ViewpointsSourceMode
    {
        CurrentSelection = 0,
        SelectionSets = 1,
        // Phase 2:
        PropertyGroups = 2,
    }

    public enum ViewDirectionPreset
    {
        IsoSE = 0,
        IsoSW = 1,
        Top = 2,
        Bottom = 3,
        Front = 4,
        Back = 5,
        Left = 6,
        Right = 7,
    }

    public enum ProjectionMode
    {
        Perspective = 0,
        Orthographic = 1
    }

    public sealed class ViewpointsGeneratorSettings : INotifyPropertyChanged
    {
        private ViewpointsSourceMode _sourceMode = ViewpointsSourceMode.SelectionSets;
        private string _outputFolderPath = "MicroEng/Viewpoints Generator";
        private string _namePrefix = "";
        private string _nameSuffix = "";
        private ViewDirectionPreset _direction = ViewDirectionPreset.IsoSE;
        private ProjectionMode _projection = ProjectionMode.Perspective;
        private double _fitMarginFactor = 0.15; // 15% of diagonal

        public ViewpointsSourceMode SourceMode { get => _sourceMode; set { _sourceMode = value; OnPropertyChanged(); } }
        public string OutputFolderPath { get => _outputFolderPath; set { _outputFolderPath = value; OnPropertyChanged(); } }

        public string NamePrefix { get => _namePrefix; set { _namePrefix = value; OnPropertyChanged(); } }
        public string NameSuffix { get => _nameSuffix; set { _nameSuffix = value; OnPropertyChanged(); } }

        public ViewDirectionPreset Direction { get => _direction; set { _direction = value; OnPropertyChanged(); } }
        public ProjectionMode Projection { get => _projection; set { _projection = value; OnPropertyChanged(); } }

        /// <summary>
        /// Extra margin added to camera distance as a fraction of bbox diagonal.
        /// </summary>
        public double FitMarginFactor { get => _fitMarginFactor; set { _fitMarginFactor = Math.Max(0, value); OnPropertyChanged(); } }

        public event PropertyChangedEventHandler PropertyChanged;
        private void OnPropertyChanged([CallerMemberName] string prop = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(prop));
    }

    public sealed class ViewpointPlanItem : INotifyPropertyChanged
    {
        private bool _enabled = true;
        private string _name = "";
        private string _source = "";
        private int _itemCount;

        public bool Enabled { get => _enabled; set { _enabled = value; OnPropertyChanged(); } }
        public string Name { get => _name; set { _name = value ?? ""; OnPropertyChanged(); } }
        public string Source { get => _source; set { _source = value ?? ""; OnPropertyChanged(); } }
        public int ItemCount { get => _itemCount; set { _itemCount = value; OnPropertyChanged(); } }

        /// <summary>
        /// Runtime-only resolver for the items this viewpoint should frame.
        /// Not databound / not serialized.
        /// </summary>
        internal Func<Autodesk.Navisworks.Api.ModelItemCollection> ResolveItems { get; set; }

        public event PropertyChangedEventHandler PropertyChanged;
        private void OnPropertyChanged([CallerMemberName] string prop = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(prop));
    }

    public sealed class SelectionSetPickerItem : INotifyPropertyChanged
    {
        private bool _enabled = true;
        private string _path = "";
        private Autodesk.Navisworks.Api.DocumentParts.SelectionSet _set;

        public bool Enabled { get => _enabled; set { _enabled = value; OnPropertyChanged(); } }
        public string Path { get => _path; set { _path = value ?? ""; OnPropertyChanged(); } }

        public Autodesk.Navisworks.Api.DocumentParts.SelectionSet Set { get => _set; set { _set = value; OnPropertyChanged(); } }

        public event PropertyChangedEventHandler PropertyChanged;
        private void OnPropertyChanged([CallerMemberName] string prop = null) => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(prop));
    }
}
```

---

## 3) Implement Navisworks service (plan + generation)

### `ViewpointsGeneratorNavisworksService.cs`

This is the core logic: build plan items, compute bounds, create fitted viewpoint, and save.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Autodesk.Navisworks.Api;
using Autodesk.Navisworks.Api.DocumentParts;

namespace MicroEng.Navisworks.ViewpointsGenerator
{
    internal static class ViewpointsGeneratorNavisworksService
    {
        public static List<SelectionSetPickerItem> LoadSelectionSets(Document doc)
        {
            var results = new List<SelectionSetPickerItem>();
            if (doc?.SelectionSets?.RootItem == null)
                return results;

            void Walk(GroupItem parent, string prefix)
            {
                foreach (var child in parent.Children)
                {
                    if (child is FolderItem folder)
                    {
                        Walk(folder, CombinePath(prefix, folder.DisplayName));
                    }
                    else if (child is SelectionSet set)
                    {
                        results.Add(new SelectionSetPickerItem
                        {
                            Enabled = true,
                            Set = set,
                            Path = CombinePath(prefix, set.DisplayName),
                        });
                    }
                }
            }

            Walk(doc.SelectionSets.RootItem, "");
            return results.OrderBy(x => x.Path).ToList();
        }

        public static List<ViewpointPlanItem> BuildPlan(
            Document doc,
            ViewpointsGeneratorSettings settings,
            IEnumerable<SelectionSetPickerItem> selectedSets)
        {
            if (doc == null) throw new ArgumentNullException(nameof(doc));
            if (settings == null) throw new ArgumentNullException(nameof(settings));

            switch (settings.SourceMode)
            {
                case ViewpointsSourceMode.CurrentSelection:
                    return BuildFromCurrentSelection(doc, settings);

                case ViewpointsSourceMode.SelectionSets:
                    return BuildFromSelectionSets(doc, settings, selectedSets);

                // Phase 2:
                case ViewpointsSourceMode.PropertyGroups:
                default:
                    return new List<ViewpointPlanItem>();
            }
        }

        private static List<ViewpointPlanItem> BuildFromCurrentSelection(Document doc, ViewpointsGeneratorSettings settings)
        {
            var items = doc.CurrentSelection?.SelectedItems;
            int count = items?.Count ?? 0;

            return new List<ViewpointPlanItem>
            {
                new ViewpointPlanItem
                {
                    Enabled = true,
                    Name = MakeName(settings, "Selection"),
                    Source = "Current Selection",
                    ItemCount = count,
                    ResolveItems = () => doc.CurrentSelection?.SelectedItems ?? new ModelItemCollection()
                }
            };
        }

        private static List<ViewpointPlanItem> BuildFromSelectionSets(
            Document doc,
            ViewpointsGeneratorSettings settings,
            IEnumerable<SelectionSetPickerItem> selectedSets)
        {
            var plan = new List<ViewpointPlanItem>();
            var sets = (selectedSets ?? Enumerable.Empty<SelectionSetPickerItem>())
                .Where(s => s != null && s.Enabled && s.Set != null)
                .ToList();

            foreach (var s in sets)
            {
                // Estimate count now so preview grid is useful.
                var resolved = ResolveSelectionSetItems(doc, s.Set);
                int count = resolved?.Count ?? 0;

                string shortName = string.IsNullOrWhiteSpace(s.Path) ? s.Set.DisplayName : s.Path;
                plan.Add(new ViewpointPlanItem
                {
                    Enabled = true,
                    Name = MakeName(settings, shortName),
                    Source = $"SelectionSet: {shortName}",
                    ItemCount = count,
                    ResolveItems = () => ResolveSelectionSetItems(doc, s.Set) ?? new ModelItemCollection()
                });
            }

            return plan;
        }

        public static void GenerateSavedViewpoints(
            Document doc,
            ViewpointsGeneratorSettings settings,
            IReadOnlyList<ViewpointPlanItem> planItems,
            Action<int, int, string> progress // (done, total, currentName)
        )
        {
            if (doc == null) throw new ArgumentNullException(nameof(doc));
            if (settings == null) throw new ArgumentNullException(nameof(settings));
            if (planItems == null) throw new ArgumentNullException(nameof(planItems));

            var enabled = planItems.Where(p => p != null && p.Enabled).ToList();
            int total = enabled.Count;

            // Ensure output folder exists under Saved Viewpoints
            var folder = EnsureSavedViewpointFolder(doc, settings.OutputFolderPath);

            for (int i = 0; i < total; i++)
            {
                var plan = enabled[i];
                progress?.Invoke(i, total, plan.Name);

                var items = plan.ResolveItems?.Invoke() ?? new ModelItemCollection();
                if (items.Count == 0)
                    continue;

                if (!TryComputeBounds(items, out var bbox))
                    continue;

                var vp = CreateFittedViewpoint(doc, bbox, settings);
                var saved = CreateSavedViewpoint(vp, plan.Name);

                // AddCopy returns void in your API usage pattern; add then optionally re-find.
                folder.Children.AddCopy(saved);
            }

            progress?.Invoke(total, total, "Done");
        }

        // ---------------------------
        // Saved Viewpoints folder tree
        // ---------------------------

        private static GroupItem EnsureSavedViewpointFolder(Document doc, string folderPath)
        {
            // doc.SavedViewpoints.RootItem is a Folder-like GroupItem
            GroupItem current = doc.SavedViewpoints.RootItem;

            var parts = (folderPath ?? "")
                .Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(x => x.Trim())
                .Where(x => !string.IsNullOrWhiteSpace(x))
                .ToList();

            foreach (var part in parts)
            {
                var existing = FindChildFolder(current, part);
                if (existing != null)
                {
                    current = existing;
                    continue;
                }

                var f = new FolderItem { DisplayName = part };
                current.Children.AddCopy(f);

                // AddCopy returns void, so re-find
                existing = FindChildFolder(current, part);
                current = existing ?? current;
            }

            return current;
        }

        private static FolderItem FindChildFolder(GroupItem parent, string name)
        {
            foreach (var child in parent.Children)
            {
                if (child is FolderItem folder && string.Equals(folder.DisplayName, name, StringComparison.OrdinalIgnoreCase))
                    return folder;
            }
            return null;
        }

        private static string CombinePath(string a, string b)
        {
            if (string.IsNullOrWhiteSpace(a)) return b ?? "";
            if (string.IsNullOrWhiteSpace(b)) return a ?? "";
            return a.TrimEnd('/', '\\') + "/" + b.TrimStart('/', '\\');
        }

        private static string MakeName(ViewpointsGeneratorSettings settings, string baseName)
        {
            var name = (baseName ?? "").Trim();
            if (name.Length == 0) name = "View";

            var p = (settings.NamePrefix ?? "").Trim();
            var s = (settings.NameSuffix ?? "").Trim();

            string outName = name;
            if (p.Length > 0) outName = p + outName;
            if (s.Length > 0) outName = outName + s;
            return outName;
        }

        // ---------------------------
        // SelectionSet resolve helpers
        // ---------------------------

        private static ModelItemCollection ResolveSelectionSetItems(Document doc, SelectionSet set)
        {
            // Search-based selection set:
            var searchProp = set.GetType().GetProperty("Search", BindingFlags.Instance | BindingFlags.Public);
            var search = searchProp?.GetValue(set) as Search;
            if (search != null)
                return search.FindAll(doc, false);

            // Explicit selection set:
            // Use reflection to support your API version (property names can vary)
            var explicitProp = set.GetType().GetProperty("ExplicitModelItems", BindingFlags.Instance | BindingFlags.Public);
            var explicitItems = explicitProp?.GetValue(set) as ModelItemCollection;
            if (explicitItems != null)
                return explicitItems;

            // Fallback: empty
            return new ModelItemCollection();
        }

        // ---------------------------
        // Viewpoint creation / camera fitting
        // ---------------------------

        private static SavedViewpoint CreateSavedViewpoint(Viewpoint viewpoint, string name)
        {
            // Most Navisworks versions support new SavedViewpoint(viewpoint)
            try
            {
                var sv = new SavedViewpoint(viewpoint) { DisplayName = name };
                return sv;
            }
            catch
            {
                // Fallback if constructor signature differs:
                var sv = new SavedViewpoint { DisplayName = name };
                // Try set Viewpoint via reflection
                var vpProp = sv.GetType().GetProperty("Viewpoint", BindingFlags.Instance | BindingFlags.Public);
                vpProp?.SetValue(sv, viewpoint);
                return sv;
            }
        }

        private static Viewpoint CreateFittedViewpoint(Document doc, BoundingBox3D bbox, ViewpointsGeneratorSettings settings)
        {
            // Copy current viewpoint where possible
            Viewpoint vp = doc.CurrentViewpoint;
            var copyMethod = vp.GetType().GetMethod("CreateCopy", BindingFlags.Instance | BindingFlags.Public);
            if (copyMethod != null)
                vp = (Viewpoint)copyMethod.Invoke(vp, null);

            FitCameraToBox(vp, bbox, settings.Direction, settings.Projection, settings.FitMarginFactor);
            return vp;
        }

        private static void FitCameraToBox(Viewpoint vp, BoundingBox3D bbox, ViewDirectionPreset dir, ProjectionMode proj, double marginFactor)
        {
            var min = bbox.Min;
            var max = bbox.Max;

            var cx = (min.X + max.X) * 0.5;
            var cy = (min.Y + max.Y) * 0.5;
            var cz = (min.Z + max.Z) * 0.5;

            var sx = (max.X - min.X);
            var sy = (max.Y - min.Y);
            var sz = (max.Z - min.Z);

            double diag = Math.Sqrt(sx * sx + sy * sy + sz * sz);
            if (diag < 1e-6) diag = 1.0;

            double distance = diag * (1.2 + marginFactor);

            // Direction vector and Up vector
            var (vx, vy, vz, ux, uy, uz) = GetPresetVectors(dir);

            // Normalize view vector
            double vlen = Math.Sqrt(vx * vx + vy * vy + vz * vz);
            if (vlen < 1e-9) { vx = 1; vy = 1; vz = 1; vlen = Math.Sqrt(3); }
            vx /= vlen; vy /= vlen; vz /= vlen;

            var pos = new Point3D(cx + vx * distance, cy + vy * distance, cz + vz * distance);
            var tgt = new Point3D(cx, cy, cz);
            var up = new Vector3D(ux, uy, uz);

            // Set camera via reflection to avoid API differences
            var camProp = vp.GetType().GetProperty("Camera", BindingFlags.Instance | BindingFlags.Public);
            var camObj = camProp?.GetValue(vp);
            if (camObj == null)
                return;

            SetIfExists(camObj, "Position", pos);
            SetIfExists(camObj, "Target", tgt);
            SetIfExists(camObj, "UpVector", up);

            // Projection (enum varies between versions)
            var projProp = camObj.GetType().GetProperty("Projection", BindingFlags.Instance | BindingFlags.Public);
            if (projProp != null && projProp.PropertyType.IsEnum)
            {
                string want = (proj == ProjectionMode.Orthographic) ? "Orthographic" : "Perspective";
                try
                {
                    object enumVal = Enum.GetValues(projProp.PropertyType)
                        .Cast<object>()
                        .FirstOrDefault(v => string.Equals(v.ToString(), want, StringComparison.OrdinalIgnoreCase));

                    if (enumVal != null)
                        projProp.SetValue(camObj, enumVal);
                }
                catch { /* ignore */ }
            }

            // If Camera is a struct in this API version, write it back:
            try { camProp?.SetValue(vp, camObj); } catch { /* ignore */ }
        }

        private static (double vx, double vy, double vz, double ux, double uy, double uz) GetPresetVectors(ViewDirectionPreset dir)
        {
            // View vector points FROM target TO camera
            // Up vector is world-ish
            switch (dir)
            {
                case ViewDirectionPreset.Top: return (0, 0, 1, 0, 1, 0);
                case ViewDirectionPreset.Bottom: return (0, 0, -1, 0, 1, 0);
                case ViewDirectionPreset.Front: return (0, -1, 0, 0, 0, 1);
                case ViewDirectionPreset.Back: return (0, 1, 0, 0, 0, 1);
                case ViewDirectionPreset.Left: return (-1, 0, 0, 0, 0, 1);
                case ViewDirectionPreset.Right: return (1, 0, 0, 0, 0, 1);
                case ViewDirectionPreset.IsoSW: return (-1, -1, 1, 0, 0, 1);
                case ViewDirectionPreset.IsoSE:
                default:
                    return (1, -1, 1, 0, 0, 1);
            }
        }

        private static void SetIfExists(object obj, string propName, object value)
        {
            var p = obj.GetType().GetProperty(propName, BindingFlags.Instance | BindingFlags.Public);
            if (p != null && p.CanWrite)
            {
                try { p.SetValue(obj, value); } catch { /* ignore */ }
            }
        }

        // ---------------------------
        // Bounds
        // ---------------------------

        private static bool TryComputeBounds(ModelItemCollection items, out BoundingBox3D bbox)
        {
            // Try fast path: ModelItemCollection.BoundingBox (method or property)
            if (TryGetBoundingBox(items, out bbox))
                return true;

            bool any = false;
            BoundingBox3D acc = default;

            foreach (var it in items)
            {
                if (it == null) continue;
                if (!TryGetBoundingBox(it, out var b))
                    continue;

                if (!any)
                {
                    acc = b;
                    any = true;
                }
                else
                {
                    acc = Union(acc, b);
                }
            }

            bbox = acc;
            return any;
        }

        private static bool TryGetBoundingBox(object obj, out BoundingBox3D bbox)
        {
            bbox = default;

            // Property "BoundingBox"
            var prop = obj.GetType().GetProperty("BoundingBox", BindingFlags.Instance | BindingFlags.Public);
            if (prop != null && prop.PropertyType == typeof(BoundingBox3D))
            {
                try
                {
                    bbox = (BoundingBox3D)prop.GetValue(obj);
                    return true;
                }
                catch { }
            }

            // Method "BoundingBox()"
            var method = obj.GetType().GetMethod("BoundingBox", BindingFlags.Instance | BindingFlags.Public, null, Type.EmptyTypes, null);
            if (method != null && method.ReturnType == typeof(BoundingBox3D))
            {
                try
                {
                    bbox = (BoundingBox3D)method.Invoke(obj, null);
                    return true;
                }
                catch { }
            }

            return false;
        }

        private static BoundingBox3D Union(BoundingBox3D a, BoundingBox3D b)
        {
            var min = new Point3D(
                Math.Min(a.Min.X, b.Min.X),
                Math.Min(a.Min.Y, b.Min.Y),
                Math.Min(a.Min.Z, b.Min.Z));

            var max = new Point3D(
                Math.Max(a.Max.X, b.Max.X),
                Math.Max(a.Max.Y, b.Max.Y),
                Math.Max(a.Max.Z, b.Max.Z));

            return new BoundingBox3D(min, max);
        }
    }
}
```

---

## 4) Add WPF UI

### `ViewpointsGeneratorWindow.xaml`

Use the same styling approach as Smart Sets. Keep controls standard WPF (not `ui:` tags that may not exist in WPF-UI).

```xml
<Window x:Class="MicroEng.Navisworks.ViewpointsGenerator.ViewpointsGeneratorWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Viewpoints Generator" Height="720" Width="1000"
        WindowStartupLocation="CenterOwner">
    <Grid>
        <local:ViewpointsGeneratorControl />
    </Grid>
</Window>
```

> Codex: ensure correct xmlns `local` based on your namespace/assembly.

### `ViewpointsGeneratorWindow.xaml.cs`

```csharp
using System.Windows;

namespace MicroEng.Navisworks.ViewpointsGenerator
{
    public partial class ViewpointsGeneratorWindow : Window
    {
        public ViewpointsGeneratorWindow()
        {
            InitializeComponent();

            // Match the pattern used in SmartSetGeneratorWindow:
            MicroEngWpfUiTheme.ApplyTo(this);
            MicroEngWindowPositioning.RestoreOrCenter(this, "ViewpointsGeneratorWindow");
        }
    }
}
```

### `ViewpointsGeneratorControl.xaml`

A simple UI: choose source mode, output folder, preset camera, preview, generate.

```xml
<UserControl x:Class="MicroEng.Navisworks.ViewpointsGenerator.ViewpointsGeneratorControl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d">

    <Grid Margin="16">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <DockPanel Grid.Row="0" Margin="0,0,0,12">
            <TextBlock Text="Viewpoints Generator" FontSize="18" FontWeight="SemiBold" />
        </DockPanel>

        <!-- Settings -->
        <Border Grid.Row="1" Padding="12" CornerRadius="6" BorderThickness="1" BorderBrush="#2A2A2A" Background="#1E1E1E">
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="160"/>
                    <ColumnDefinition Width="260"/>
                    <ColumnDefinition Width="20"/>
                    <ColumnDefinition Width="160"/>
                    <ColumnDefinition Width="260"/>
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="10"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>

                <TextBlock Grid.Row="0" Grid.Column="0" Text="Source:" VerticalAlignment="Center"/>
                <ComboBox Grid.Row="0" Grid.Column="1"
                          ItemsSource="{Binding SourceModes}"
                          SelectedItem="{Binding Settings.SourceMode}"
                          MinWidth="220"/>

                <TextBlock Grid.Row="0" Grid.Column="3" Text="Output folder:" VerticalAlignment="Center"/>
                <TextBox Grid.Row="0" Grid.Column="4"
                         Text="{Binding Settings.OutputFolderPath}"
                         MinWidth="220"/>

                <TextBlock Grid.Row="2" Grid.Column="0" Text="View direction:" VerticalAlignment="Center"/>
                <ComboBox Grid.Row="2" Grid.Column="1"
                          ItemsSource="{Binding DirectionPresets}"
                          SelectedItem="{Binding Settings.Direction}"
                          MinWidth="220"/>

                <TextBlock Grid.Row="2" Grid.Column="3" Text="Projection:" VerticalAlignment="Center"/>
                <ComboBox Grid.Row="2" Grid.Column="4"
                          ItemsSource="{Binding ProjectionModes}"
                          SelectedItem="{Binding Settings.Projection}"
                          MinWidth="220"/>
            </Grid>
        </Border>

        <!-- Selection Sets picker (shown only when SourceMode == SelectionSets) -->
        <Grid Grid.Row="2" Margin="0,12,0,12">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="340"/>
                <ColumnDefinition Width="12"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <Border Grid.Column="0" Padding="12" CornerRadius="6" BorderThickness="1" BorderBrush="#2A2A2A" Background="#1E1E1E">
                <DockPanel>
                    <StackPanel DockPanel.Dock="Top" Orientation="Horizontal" Margin="0,0,0,8">
                        <TextBlock Text="Selection/Search Sets" FontWeight="SemiBold" />
                        <Button Content="Refresh" Margin="12,0,0,0" Padding="10,4" Click="RefreshSets_Click"/>
                    </StackPanel>

                    <DataGrid ItemsSource="{Binding SelectionSets}"
                              AutoGenerateColumns="False"
                              HeadersVisibility="Column"
                              CanUserAddRows="False"
                              CanUserDeleteRows="False"
                              IsReadOnly="False"
                              FontSize="12"
                              RowHeight="26">
                        <DataGrid.Columns>
                            <DataGridCheckBoxColumn Header="On" Binding="{Binding Enabled}" Width="40"/>
                            <DataGridTextColumn Header="Set" Binding="{Binding Path}" Width="*"/>
                        </DataGrid.Columns>
                    </DataGrid>
                </DockPanel>
            </Border>

            <Border Grid.Column="2" Padding="12" CornerRadius="6" BorderThickness="1" BorderBrush="#2A2A2A" Background="#1E1E1E">
                <DockPanel>
                    <StackPanel DockPanel.Dock="Top" Orientation="Horizontal" Margin="0,0,0,8">
                        <TextBlock Text="Preview Plan" FontWeight="SemiBold" />
                        <Button Content="Preview" Margin="12,0,0,0" Padding="10,4" Click="Preview_Click"/>
                    </StackPanel>

                    <DataGrid ItemsSource="{Binding Plan}"
                              AutoGenerateColumns="False"
                              HeadersVisibility="Column"
                              CanUserAddRows="False"
                              CanUserDeleteRows="False"
                              IsReadOnly="False"
                              FontSize="12"
                              RowHeight="26">
                        <DataGrid.Columns>
                            <DataGridCheckBoxColumn Header="On" Binding="{Binding Enabled}" Width="40"/>
                            <DataGridTextColumn Header="Viewpoint Name" Binding="{Binding Name}" Width="*"/>
                            <DataGridTextColumn Header="Source" Binding="{Binding Source}" Width="260"/>
                            <DataGridTextColumn Header="Count" Binding="{Binding ItemCount}" Width="70"/>
                        </DataGrid.Columns>
                    </DataGrid>
                </DockPanel>
            </Border>
        </Grid>

        <!-- Actions -->
        <DockPanel Grid.Row="3">
            <TextBlock Text="{Binding StatusText}" VerticalAlignment="Center" />
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right" DockPanel.Dock="Right">
                <Button Content="Generate" Padding="14,6" Margin="8,0,0,0" Click="Generate_Click"/>
            </StackPanel>
        </DockPanel>
    </Grid>
</UserControl>
```

### `ViewpointsGeneratorControl.xaml.cs`

```csharp
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using Autodesk.Navisworks.Api;

namespace MicroEng.Navisworks.ViewpointsGenerator
{
    public partial class ViewpointsGeneratorControl : UserControl
    {
        public ViewpointsGeneratorSettings Settings { get; } = new ViewpointsGeneratorSettings();

        public ObservableCollection<ViewpointsSourceMode> SourceModes { get; } =
            new ObservableCollection<ViewpointsSourceMode>((ViewpointsSourceMode[])Enum.GetValues(typeof(ViewpointsSourceMode)));

        public ObservableCollection<ViewDirectionPreset> DirectionPresets { get; } =
            new ObservableCollection<ViewDirectionPreset>((ViewDirectionPreset[])Enum.GetValues(typeof(ViewDirectionPreset)));

        public ObservableCollection<ProjectionMode> ProjectionModes { get; } =
            new ObservableCollection<ProjectionMode>((ProjectionMode[])Enum.GetValues(typeof(ProjectionMode)));

        public ObservableCollection<SelectionSetPickerItem> SelectionSets { get; } = new ObservableCollection<SelectionSetPickerItem>();
        public ObservableCollection<ViewpointPlanItem> Plan { get; } = new ObservableCollection<ViewpointPlanItem>();

        public string StatusText { get; set; } = "Ready.";

        public ViewpointsGeneratorControl()
        {
            InitializeComponent();
            DataContext = this;

            Loaded += (_, __) => RefreshSets();
        }

        private void RefreshSets_Click(object sender, RoutedEventArgs e) => RefreshSets();

        private void RefreshSets()
        {
            try
            {
                SelectionSets.Clear();

                var doc = Autodesk.Navisworks.Api.Application.ActiveDocument;
                if (doc == null)
                {
                    StatusText = "No active document.";
                    return;
                }

                foreach (var s in ViewpointsGeneratorNavisworksService.LoadSelectionSets(doc))
                    SelectionSets.Add(s);

                StatusText = $"Loaded {SelectionSets.Count} sets.";
            }
            catch (Exception ex)
            {
                StatusText = "Failed to load sets: " + ex.Message;
            }
        }

        private void Preview_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                Plan.Clear();

                var doc = Autodesk.Navisworks.Api.Application.ActiveDocument;
                if (doc == null)
                {
                    StatusText = "No active document.";
                    return;
                }

                var plan = ViewpointsGeneratorNavisworksService.BuildPlan(doc, Settings, SelectionSets);
                foreach (var p in plan)
                    Plan.Add(p);

                StatusText = $"Plan: {Plan.Count(p => p.Enabled)} viewpoints enabled ({Plan.Count} total).";
            }
            catch (Exception ex)
            {
                StatusText = "Preview failed: " + ex.Message;
            }
        }

        private async void Generate_Click(object sender, RoutedEventArgs e)
        {
            var doc = Autodesk.Navisworks.Api.Application.ActiveDocument;
            if (doc == null)
            {
                StatusText = "No active document.";
                return;
            }

            var enabledCount = Plan.Count(x => x.Enabled);
            if (enabledCount == 0)
            {
                StatusText = "Nothing enabled in preview plan.";
                return;
            }

            StatusText = "Generating viewpoints...";

            // IMPORTANT: Navisworks API is generally single-threaded; keep this on UI thread.
            // We only wrap in Task.Yield to keep UI responsive.
            await Task.Yield();

            try
            {
                ViewpointsGeneratorNavisworksService.GenerateSavedViewpoints(
                    doc,
                    Settings,
                    Plan.ToList(),
                    (done, total, name) =>
                    {
                        StatusText = (done >= total)
                            ? "Done."
                            : $"Creating {done + 1}/{total}: {name}";
                    });

                StatusText = "Done. Viewpoints created.";
            }
            catch (Exception ex)
            {
                StatusText = "Generate failed: " + ex.Message;
            }
        }
    }
}
```

---

## 5) Add plugin registration (dock pane + command)

### `ViewpointsGeneratorPlugins.cs`

Match the `SmartSetGeneratorPlugins.cs` structure.

```csharp
using System;
using System.Windows.Forms.Integration;
using Autodesk.Navisworks.Api.Plugins;

namespace MicroEng.Navisworks.ViewpointsGenerator
{
    [Plugin("MicroEng.ViewpointsGenerator.DockPane.MENG", "MicroEng",
        DisplayName = "Viewpoints Generator",
        ToolTip = "Batch-generate Saved Viewpoints",
        LoadForCanExecute = true)]
    [DockPanePlugin(800, 600, AutoScroll = true)]
    public sealed class ViewpointsGeneratorDockPanePlugin : DockPanePlugin
    {
        private ElementHost _host;
        private ViewpointsGeneratorControl _control;

        public override System.Windows.Forms.Control CreateControlPane()
        {
            _control = new ViewpointsGeneratorControl();
            _host = new ElementHost { Dock = System.Windows.Forms.DockStyle.Fill, Child = _control };
            return _host;
        }

        public override void DestroyControlPane(System.Windows.Forms.Control pane)
        {
            try
            {
                if (_host != null)
                {
                    _host.Child = null;
                    _host.Dispose();
                    _host = null;
                }
            }
            catch { /* ignore */ }

            _control = null;
            base.DestroyControlPane(pane);
        }
    }

    [Plugin("MicroEng.ViewpointsGenerator.Command.MENG", "MicroEng",
        DisplayName = "Viewpoints Generator",
        ToolTip = "Open Viewpoints Generator",
        LoadForCanExecute = true)]
    public sealed class ViewpointsGeneratorCommandPlugin : CommandHandlerPlugin
    {
        public override int ExecuteCommand(string name, params string[] parameters)
        {
            try
            {
                // show dock pane
                var pane = Autodesk.Navisworks.Api.Application.Gui?.DockPaneManager?.FindDockPane("MicroEng.ViewpointsGenerator.DockPane.MENG");
                pane?.Show();
            }
            catch
            {
                // ignore
            }
            return 0;
        }
    }
}
```

---

## 6) Wire into your launcher panel (MicroEng panel)

Codex: follow the exact pattern used for Smart Set Generator:

* Add a new tile/button **“Viewpoints Generator”**
* Icon suggestion (WPF-UI): `ImageMultiple24` or `Camera24` or `Bookmarks24` depending on your icon pack.

Likely files (based on your existing pattern):

* `MicroEngPanelControl.xaml` (add button row)
* `MicroEngPanelControl.xaml.cs` (click handler)
* `MicroEngPlugins.cs` (register / route to command)

Action: show dock pane plugin id `MicroEng.ViewpointsGenerator.DockPane.MENG`.

---

## 7) Test checklist

1. `dotnet build MicroEng.Navisworks/MicroEng.Navisworks.csproj`
2. Launch Navisworks
3. Open MicroEng panel → Viewpoints Generator
4. In Navisworks create 1–2 selection sets or search sets
5. In tool:

   * Source = SelectionSets
   * Refresh → Preview → Generate
6. Verify Saved Viewpoints tree now contains folder `MicroEng/Viewpoints Generator` with viewpoints.

---

# Phase 2 upgrades worth doing next

If you want this tool to feel “production-grade” quickly, tell Codex to do these next (in order):

1. **Visibility capture (isolate)**

   * For each plan item: temporarily set selection, hide unselected, save viewpoint, restore.
   * Store/restore can be done using COM API state snapshots if .NET doesn’t expose a clean undo.

2. **Section box option**

   * Create a section box around bbox + padding before saving viewpoint.

3. **Scope parity with Find Items**

   * Reuse the same Scope Picker you’re building for Smart Sets (so viewpoint generation can be restricted to model roots / selection sets / current selection).

4. **Screenshot export + legend**

   * After viewpoint creation, export image, and attach a note in viewpoint.

---

## Codex prompt (copy/paste)

Use this as your Codex instruction to implement in one pass:

> Implement a new Navisworks tool “Viewpoints Generator” as a WPF UI window hosted in a DockPanePlugin (ElementHost) with a CommandHandlerPlugin to show it.
>
> Create folder `MicroEng.Navisworks/ViewpointsGenerator/` and add:
>
> * ViewpointsGeneratorModels.cs (settings, enums, plan item, selection set picker item)
> * ViewpointsGeneratorNavisworksService.cs (load selection sets, build plan, compute bounds, fit camera preset, create SavedViewpoint, ensure Saved Viewpoints folder path)
> * ViewpointsGeneratorControl.xaml + .cs (UI: source mode, output folder, view direction, projection; grids for selection sets + plan; Preview and Generate)
> * ViewpointsGeneratorWindow.xaml + .cs (apply MicroEngWpfUiTheme + MicroEngWindowPositioning)
> * ViewpointsGeneratorPlugins.cs (DockPanePlugin + CommandHandlerPlugin like SmartSetGeneratorPlugins)
>
> Keep UI controls standard WPF (ComboBox/TabControl/DataGrid) so it compiles without missing Wpf.Ui tags. Use DataGrid font size/row height similar to Data Scraper (12pt, row ~26).
>
> Wire the tool into the existing MicroEng panel launcher the same way Smart Set Generator is wired, so it can be opened from the panel.
>
> Build should succeed.

---

If you want, I can also give you the Phase 2 “Isolate + Section box + Screenshot export” work order, but the above MVP will already generate correctly framed Saved Viewpoints and is the right base to extend.
